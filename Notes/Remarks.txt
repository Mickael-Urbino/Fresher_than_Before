Priority levels to be investigated for interrupts. This is what prevented my code from workin properly

Incrémenter la PWM en step de 1% c'est pas une bonne idée.
Mieux vaut le faire en augmenter en step le OCompare, ca evite les glitchs et ça permet de fonctionner à n'importe quelle fréquence.

L'augmentation en step de 1% ça fonctionne pour les fréquence inférieures et directement proportionnels à la fréquence du timer. par exemple pour HSI = 16MHz, et aucun prescaler, la fréquence du timer 2 maximale dépend de la résolution du compteur, ici 16 bits.

donc 16MHz/2^16 = 16MHz/65535 = 244Hz. Ici, il n'y pas de virgule etc, donc les pas de 1% sont bien pris en compte. ça fonctionne pour 122Hz et 61Hz, mais pas autre chose.

#define TIM2_CH3_FREQ 20000 //Timer2_CH3 PWM Frequency in Hz (244Hz is Maximum Frequency for 16 bit timer where duty_cycle can span full range 0-99% (100% makes a glitch, avoid.) Considering HSI is 16MHz and prescalers are set to 1) Lower must stay divisible by two to have a proper range displayed.
#define TIM2_CH3_DUTY_CYCLE 0 //Timer2_CH3 pwm duty cycle in % - If frequency is too low, the counter might not reach the requested value, increase prescaler value in that case.

Il y a un glitch à 100% donc on doit limiter à 99% en plus.

Sans prescaler, la valeur minimal de frequence de PWM est 245Hz. Il faut ajouter un ou plusieurs prescaler pour aller plus bas.


Observations poru la generation du timer 2 et le reglage de la periode et du rapoprt cyclique:

//ARR => example 1Hz pwm for the timer period is 62499 tick, which is equals to a 1Hz timer2 frequency for CLK_PRESCALER_HSDIV2/TIM2_PRESCALER = 62500Hz. (The timer counts 62500 times before restarting. At a clock speed of 62500Hz, it makes timer2's period 1 second)


Removings custom duty_cycle (in percentage) function, as it creates issue for some frequencies. this was the function:
uint16_t set_pwm_duty_cycle(uint16_t duty_cycle, uint16_t arr)
{
	uint16_t OCR = 0;
	if (duty_cycle <= 100)
	{
		OCR = ((duty_cycle * (arr + 1))/100);
	}
	else
	{
		OCR = 0; //if duty_cycle value is out of range, it is forcibly set to 0. The pwm won't work
	}
	
	return OCR;	
}

it was used in tim2 init function:

//uint16_t duty_cycle = set_pwm_duty_cycle(TIM2_CH3_DUTY_CYCLE, arr);

also removed volatile uint16_t duty_cycle_tim2_ch3 = 0; as it was not used anymore for defining duty_cycle

Le timebaseinit doit etre appelé avant le OCxInit !!


Removed #define TIM2_CH3_DUTY_CYCLE 0 //Timer2_CH3 pwm duty cycle in % - If frequency is too low, the counter might not reach the requested value, increase prescaler value in that case.
#define TIM1_CH3_DUTY_CYCLE 0 //Timer1_CH3 pwm duty cycle in %

Because not used


Il semblerait que seulement 260 step sont réalisés dans le changeemtn de duty cycle de timer 1 avant d'atteindre la tension max, puis le reste des steps est fait ensuite

Equation de calcul de la frequence counter du timer 1 différente de celle du timer 2.
Timer 1 : Fck_CNT = Fck_PSC/(PSCR[15:0]+1)
Timer 2/3/5 : Fck_CNT = Fck_PSC/2^(PSCR[3:0]) 

optimisation espace : supprimer des fonctions non utilisées dans les src files:

void TIM1_OC1Init(TIM1_OCMode_TypeDef TIM1_OCMode,
                  TIM1_OutputState_TypeDef TIM1_OutputState,
                  TIM1_OutputNState_TypeDef TIM1_OutputNState,
                  uint16_t TIM1_Pulse,
                  TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
                  TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
                  TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
                  TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
{
  /* Check the parameters */
  assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
  assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
  assert_param(IS_TIM1_OUTPUTN_STATE_OK(TIM1_OutputNState));
  assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
  assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
  assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
  assert_param(IS_TIM1_OCNIDLE_STATE_OK(TIM1_OCNIdleState));
  
  /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , 
  the Output N State, the Output Polarity & the Output N Polarity*/
  TIM1->CCER1 &= (uint8_t)(~( TIM1_CCER1_CC1E | TIM1_CCER1_CC1NE 
                             | TIM1_CCER1_CC1P | TIM1_CCER1_CC1NP));
  /* Set the Output State & Set the Output N State & Set the Output Polarity &
  Set the Output N Polarity */
  TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC1E)
                                     | (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC1NE))
                           | (uint8_t)( (uint8_t)(TIM1_OCPolarity  & TIM1_CCER1_CC1P)
                                       | (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC1NP)));
  
  /* Reset the Output Compare Bits & Set the Output Compare Mode */
  TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM)) | 
                          (uint8_t)TIM1_OCMode);
  
  /* Reset the Output Idle state & the Output N Idle state bits */
  TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS1 | TIM1_OISR_OIS1N));
  /* Set the Output Idle state & the Output N Idle state configuration */
  TIM1->OISR |= (uint8_t)((uint8_t)( TIM1_OCIdleState & TIM1_OISR_OIS1 ) | 
                          (uint8_t)( TIM1_OCNIdleState & TIM1_OISR_OIS1N ));
  
  /* Set the Pulse value */
  TIM1->CCR1H = (uint8_t)(TIM1_Pulse >> 8);
  TIM1->CCR1L = (uint8_t)(TIM1_Pulse);
}

void TIM1_OC2Init(TIM1_OCMode_TypeDef TIM1_OCMode,
                  TIM1_OutputState_TypeDef TIM1_OutputState,
                  TIM1_OutputNState_TypeDef TIM1_OutputNState,
                  uint16_t TIM1_Pulse,
                  TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
                  TIM1_OCNPolarity_TypeDef TIM1_OCNPolarity,
                  TIM1_OCIdleState_TypeDef TIM1_OCIdleState,
                  TIM1_OCNIdleState_TypeDef TIM1_OCNIdleState)
{
  /* Check the parameters */
  assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
  assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
  assert_param(IS_TIM1_OUTPUTN_STATE_OK(TIM1_OutputNState));
  assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
  assert_param(IS_TIM1_OCN_POLARITY_OK(TIM1_OCNPolarity));
  assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
  assert_param(IS_TIM1_OCNIDLE_STATE_OK(TIM1_OCNIdleState));
  
  /* Disable the Channel 1: Reset the CCE Bit, Set the Output State , 
  the Output N State, the Output Polarity & the Output N Polarity*/
  TIM1->CCER1 &= (uint8_t)(~( TIM1_CCER1_CC2E | TIM1_CCER1_CC2NE | 
                             TIM1_CCER1_CC2P | TIM1_CCER1_CC2NP));
  
  /* Set the Output State & Set the Output N State & Set the Output Polarity &
  Set the Output N Polarity */
  TIM1->CCER1 |= (uint8_t)((uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER1_CC2E  ) | 
                                     (uint8_t)(TIM1_OutputNState & TIM1_CCER1_CC2NE )) | 
                           (uint8_t)((uint8_t)(TIM1_OCPolarity  & TIM1_CCER1_CC2P  ) | 
                                     (uint8_t)(TIM1_OCNPolarity & TIM1_CCER1_CC2NP )));
  
  /* Reset the Output Compare Bits & Set the Output Compare Mode */
  TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM)) | 
                          (uint8_t)TIM1_OCMode);
  
  /* Reset the Output Idle state & the Output N Idle state bits */
  TIM1->OISR &= (uint8_t)(~(TIM1_OISR_OIS2 | TIM1_OISR_OIS2N));
  /* Set the Output Idle state & the Output N Idle state configuration */
  TIM1->OISR |= (uint8_t)((uint8_t)(TIM1_OISR_OIS2 & TIM1_OCIdleState) | 
                          (uint8_t)(TIM1_OISR_OIS2N & TIM1_OCNIdleState));
  
  /* Set the Pulse value */
  TIM1->CCR2H = (uint8_t)(TIM1_Pulse >> 8);
  TIM1->CCR2L = (uint8_t)(TIM1_Pulse);
}



void TIM1_OC4Init(TIM1_OCMode_TypeDef TIM1_OCMode,
                  TIM1_OutputState_TypeDef TIM1_OutputState,
                  uint16_t TIM1_Pulse,
                  TIM1_OCPolarity_TypeDef TIM1_OCPolarity,
                  TIM1_OCIdleState_TypeDef TIM1_OCIdleState)
{
  /* Check the parameters */
  assert_param(IS_TIM1_OC_MODE_OK(TIM1_OCMode));
  assert_param(IS_TIM1_OUTPUT_STATE_OK(TIM1_OutputState));
  assert_param(IS_TIM1_OC_POLARITY_OK(TIM1_OCPolarity));
  assert_param(IS_TIM1_OCIDLE_STATE_OK(TIM1_OCIdleState));
  
  /* Disable the Channel 4: Reset the CCE Bit */
  TIM1->CCER2 &= (uint8_t)(~(TIM1_CCER2_CC4E | TIM1_CCER2_CC4P));
  /* Set the Output State  &  the Output Polarity */
  TIM1->CCER2 |= (uint8_t)((uint8_t)(TIM1_OutputState & TIM1_CCER2_CC4E ) |  
                           (uint8_t)(TIM1_OCPolarity  & TIM1_CCER2_CC4P ));
  
  /* Reset the Output Compare Bit  and Set the Output Compare Mode */
  TIM1->CCMR4 = (uint8_t)((uint8_t)(TIM1->CCMR4 & (uint8_t)(~TIM1_CCMR_OCM)) | 
                          TIM1_OCMode);
  
  /* Set the Output Idle state */
  if (TIM1_OCIdleState != TIM1_OCIDLESTATE_RESET)
  {
    TIM1->OISR |= (uint8_t)(~TIM1_CCER2_CC4P);
  }
  else
  {
    TIM1->OISR &= (uint8_t)(~TIM1_OISR_OIS4);
  }
  
  /* Set the Pulse value */
  TIM1->CCR4H = (uint8_t)(TIM1_Pulse >> 8);
  TIM1->CCR4L = (uint8_t)(TIM1_Pulse);
}




/**
  * @brief  Configures the TIM1 peripheral in PWM Input Mode according to the 
  *         specified parameters.
  * @param  TIM1_Channel specifies the input capture channel from 
  *         @ref TIM1_Channel_TypeDef.
  * @param  TIM1_ICPolarity specifies the Input capture polarity from  
  *         @ref TIM1_ICPolarity_TypeDef .
  * @param  TIM1_ICSelection specifies the Input capture source selection  from
  *         @ref TIM1_ICSelection_TypeDef.
  * @param  TIM1_ICPrescaler specifies the Input capture Prescaler from  
  *         @ref TIM1_ICPSC_TypeDef.
  * @param  TIM1_ICFilter specifies the Input capture filter value.
  * @retval None
  */
void TIM1_PWMIConfig(TIM1_Channel_TypeDef TIM1_Channel,
                     TIM1_ICPolarity_TypeDef TIM1_ICPolarity,
                     TIM1_ICSelection_TypeDef TIM1_ICSelection,
                     TIM1_ICPSC_TypeDef TIM1_ICPrescaler,
                     uint8_t TIM1_ICFilter)
{


/**
  * @brief  Enables or Disables the TIM1’s Hall sensor interface.
  * @param   NewState new state of the TIM1 Hall sensor interface.This parameter can
  * be ENABLE or DISABLE.
  * @retval None
  */
void TIM1_SelectHallSensor(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONALSTATE_OK(NewState));
  
  /* Set or Reset the TI1S Bit */
  if (NewState != DISABLE)
  {
    TIM1->CR2 |= TIM1_CR2_TI1S;
  }
  else
  {
    TIM1->CR2 &= (uint8_t)(~TIM1_CR2_TI1S);
  }
}


/**
  * @brief  Selects the TIM1’s One Pulse Mode.
  * @param   TIM1_OPMode specifies the OPM Mode to be used.
  * This parameter can be one of the following values
  *                    - TIM1_OPMODE_SINGLE
  *                    - TIM1_OPMODE_REPETITIVE
  * @retval None
  */
void TIM1_SelectOnePulseMode(TIM1_OPMode_TypeDef TIM1_OPMode)
{
  /* Check the parameters */
  assert_param(IS_TIM1_OPM_MODE_OK(TIM1_OPMode));
  
  /* Set or Reset the OPM Bit */
  if (TIM1_OPMode != TIM1_OPMODE_REPETITIVE)
  {
    TIM1->CR1 |= TIM1_CR1_OPM;
  }
  else
  {
    TIM1->CR1 &= (uint8_t)(~TIM1_CR1_OPM);
  }
  
}


/**
  * @brief  Configures the TIM1 Encoder Interface.
  * @param   TIM1_EncoderMode specifies the TIM1 Encoder Mode.
  * This parameter can be one of the following values
  * - TIM1_ENCODERMODE_TI1: Counter counts on TI1FP1 edge
	* depending on TI2FP2 level.
  * - TIM1_ENCODERMODE_TI2: Counter counts on TI2FP2 edge
  *	depending on TI1FP1 level.
  * - TIM1_ENCODERMODE_TI12: Counter counts on both TI1FP1 and
  * TI2FP2 edges depending on the level of the other input.
  * @param   TIM1_IC1Polarity specifies the IC1 Polarity.
  * This parameter can be one of the following values
  *                       - TIM1_ICPOLARITY_FALLING
  *                       - TIM1_ICPOLARITY_RISING
  * @param   TIM1_IC2Polarity specifies the IC2 Polarity.
  * This parameter can be one of the following values
  *                       - TIM1_ICPOLARITY_FALLING
  *                       - TIM1_ICPOLARITY_RISING
  * @retval None
  */
void TIM1_EncoderInterfaceConfig(TIM1_EncoderMode_TypeDef TIM1_EncoderMode,
                                 TIM1_ICPolarity_TypeDef TIM1_IC1Polarity,
                                 TIM1_ICPolarity_TypeDef TIM1_IC2Polarity)
{
  /* Check the parameters */
  assert_param(IS_TIM1_ENCODER_MODE_OK(TIM1_EncoderMode));
  assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_IC1Polarity));
  assert_param(IS_TIM1_IC_POLARITY_OK(TIM1_IC2Polarity));
  
  /* Set the TI1 and the TI2 Polarities */
  if (TIM1_IC1Polarity != TIM1_ICPOLARITY_RISING)
  {
    TIM1->CCER1 |= TIM1_CCER1_CC1P;
  }
  else
  {
    TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC1P);
  }
  
  if (TIM1_IC2Polarity != TIM1_ICPOLARITY_RISING)
  {
    TIM1->CCER1 |= TIM1_CCER1_CC2P;
  }
  else
  {
    TIM1->CCER1 &= (uint8_t)(~TIM1_CCER1_CC2P);
  }
  /* Set the encoder Mode */
  TIM1->SMCR = (uint8_t)((uint8_t)(TIM1->SMCR & (uint8_t)(TIM1_SMCR_MSM | TIM1_SMCR_TS))
                         | (uint8_t) TIM1_EncoderMode);
  
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  TIM1->CCMR1 = (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_CCxS)) 
                          | (uint8_t) CCMR_TIxDirect_Set);
  TIM1->CCMR2 = (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_CCxS))
                          | (uint8_t) CCMR_TIxDirect_Set);
}


/**
  * @brief  Forces the TIM1 Channel1 output waveform to active or inactive level.
  * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
  * This parameter can be one of the following values:
  * - TIM1_FORCEDACTION_ACTIVE: Force active level on OC1REF
  * - TIM1_FORCEDACTION_INACTIVE: Force inactive level on OC1REF.
  * @retval None
  */
void TIM1_ForcedOC1Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
{
  /* Check the parameters */
  assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
  
  /* Reset the OCM Bits & Configure the Forced output Mode */
  TIM1->CCMR1 =  (uint8_t)((uint8_t)(TIM1->CCMR1 & (uint8_t)(~TIM1_CCMR_OCM))|
                           (uint8_t)TIM1_ForcedAction);
}

/**
  * @brief  Forces the TIM1 Channel2 output waveform to active or inactive level.
  * @param   TIM1_ForcedAction specifies the forced Action to be set to the output waveform.
  * This parameter can be one of the following values:
  * - TIM1_FORCEDACTION_ACTIVE: Force active level on OC2REF
  * - TIM1_FORCEDACTION_INACTIVE: Force inactive level on OC2REF.
  * @retval None
  */
void TIM1_ForcedOC2Config(TIM1_ForcedAction_TypeDef TIM1_ForcedAction)
{
  /* Check the parameters */
  assert_param(IS_TIM1_FORCED_ACTION_OK(TIM1_ForcedAction));
  
  /* Reset the OCM Bits & Configure the Forced output Mode */
  TIM1->CCMR2  =  (uint8_t)((uint8_t)(TIM1->CCMR2 & (uint8_t)(~TIM1_CCMR_OCM))
                            | (uint8_t)TIM1_ForcedAction);
}

